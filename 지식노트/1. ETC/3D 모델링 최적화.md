# 1. 3D 모델과 gltf
3D 모델은 일반적으로 파일 크기가 큰 편이고, 데이터를 스트리밍하여 받아오기도 어렵기 때문에 상대적으로 최적화가 더 필요하다
다양한 3D 모델의 종류가 있지만 대표적으로 polygonal mesh 형태의 모델이 가장 많이 사용된다.

polygonal mesh 3D 모델은 **형태(geometry), 재질(material), 동작(animation)** 이 있다

### 형태 (geometry)
정점(vertex)선(edge) 그리고 그 선들이 합쳐져 만들어지는 면(face)들로 구성되어 있다.
정점의 개수는 디테일에 따라 몇백~몇천 개부터 몇십~몇백 개까지 사용될 수 있다.

### 재질(material)
3D 모델이 어떤 색상을 갖는지, 빛을 비췄을 때는 어떤 특성을 갖고 있는지와 같이
모델 표면의 성질을 나타내는 것이 재질(material)이다. 재질을 표현하기 위해 텍스처(texture)가 사용되고, 일반적으로 2D 이미지 형태에 저장된다.

### 동작(animations)
3D 모델 내부에 뼈대를 심어 그 뼈대를 움직이는 skeletal animation(rigging) 방식을 사용한다. 실제로 사용되는 데이터의 경우 여러 저장 방식이 있으나, 대표적으로 정점마다 영향받는 뼈대의 id와 영향받는 정도(weight)를 같이 저장하는 방식이 있다.

### glTF
[glTF](https://github.com/KhronosGroup/glTF)는 3D 모델을 저장하는 형식 중 하나로, 빠르고 효율적인 데이터 구조를 갖고 있어 웹에서 많이 사용되고 있다.
glTF는 메인이 되는 JSON 형식의 glTF 파일, 그리고 형태. 동작 등 버퍼 데이터가 저장되는 바이너리 파일(.bin), 그리고 모델마다 상이하지만 다수의 텍스처 이미지로 구성된다. 혹은 이를 **전부 합하여 하나의 바이너리 파일로 구성할 수도 있으며, 이 경우 glb 형식을 사용한다**

# 2. Geometry 최적화
Geometry 최적화는 폴리곤 개수 감소와 Geometry Compression의 두 가지 측면에서 접근할 수 있다.
1. 폴리곤 개수 감소
	- 정점 및 폴리곤의 개수를 줄이기 때문에 모델의 디테일이 감소한다
	- 절대적인 데이터 양이 감소하므로 파일 크기를 줄이고 런타임 성능을 높인다.
2. Geometry Compression
	- 데이터를 압축하는 방식으로 폴리곤 개수 감소에 더해 추가로 적용할 수 있다.

### Draco Mesh Compression
[Draco](https://github.com/google/draco)는 Google이 만든  mesh/point cloud compression 라이브러리로 형태와 관련된 데이터를 높은 효율로 압축한다.
다만 애니메이션 관련 데이터나 텍스처 데이터를 압축하지는 못하는 단점이 있다.

### Meshopt Compression
[Meshoptimizer](https://github.com/zeux/meshoptimizer)는 Draco에 비해 더 lightweight한 라이브러리로 단순히 3D 모델의 파일 크기를 줄이는 것 뿐만 아니라 GPU 캐시를 더 활용하기 좋은 형태로 가공하는데 초점이 맞춰져 런타임 성능을 증가시키는데 도움을 준다.
또한 Geometry 뿐만 아니라 모든 바이너리 데이터에 대해 적용되어 애니메이션이 포함된 경우에도 관련 데이터들을 압축할 수 있다.

### 적용 기술
애니메이션이 없는 대부분의 3D 모델에는 Draco 방식의 Mesh Compression을 적용했고
애니메이션이 필요한 Player나 Npc, Pet에는 Meshopt Compression을 적용해서 압축 효율을  
극대화 하였다.

# 3. 텍스처 최적화 
텍스처는 일반적으로 2D 이미지 형태로 저장되기 때문에 일반적인 이미지 압축 기법을 적용할 수 있다.

### 텍스처 크기 변경
텍스처는 일반적으로 2의 배수 크기를 사용하기 때문에 가로/세로 크기를 절반으로만 줄여도 전체 크기는 1/4로 감소한다. 
물론 텍스처의 크기가 작아지면 모델의 디테일이 떨어지기 때문에 적절한 크기를 찾는 것이 중요하고 glTF의 경우 메인 glTF 파일이 JSON 형식이기 때문에 텍스처 이름과 확장자만 동일하면 쉽게 바꿀 수 있어 여러 이미지로 테스트 해보면서 적절한 크기를 찾을 수 있다.

### 텍스처 형식 선정과 최적화
일반적으로 사용되는 이미지 형식인 PNG, JPG WebP 등의 형식을 사용할 수 있다.
JPG와 WebP의 경우 비교적 크기가 작지만 손실 압축 방식을 사용하기 때문에 원본과 결과물이 달라질 수 있으므로 이러한 점을 고려하여 텍스처 형식을 선정해야 한다.
JPG와 WebP의 경우 다양한 손실 압축 기법을 사용할 수 있고
**PNG 또한 추가로 비손실 압축이 가능하다**

### Basis Universal 텍스처
KTX/basis는 [BasisU(Basis Universal) Supercompressed GPU Texture Codec](https://github.com/BinomialLLC/basis_universal) 을 사용하는 텍스처 이미지 형식으로, 높은 품질의 UASTC 모드와 낮은 품질의 ETC1S 모드가 있다.
Basis Universal 텍스처는 PNG, JPG 등의 일반 이미지와 GPU에서 사용하는 데이터의 중간 단계로, 빠르게 다양한 GPU 압축 픽셀 형식으로 transcode 될 수 있다. 특히 **일반 이미지와 같은 크기일 때 GPU 내에서 훨씬 더 작은 메모리 용량을 차지하여 일반적으로 파일 크기가 굉장히 작고 텍스처 이미지를 GPU에 업로드하기까지의 시간도 단축할 수 있으며 GPU 내에서의 메모리 사용량도 적다는 점 등 다양한 이점이 있다**.
다만 ETC1S 모드 사용 시 사용 옵션 및 경우에 따라 원본 이미지의 디테일이 누락되는 경우가 발생한다.

### 적용 기술
디테일을 최대한 살리는 선에서 텍스처의 size를 감소시켰고
Oxipng (멀티 스레드 무손실 PNG 압축 최적화 도구)를 사용하여 추가적으로 이미지 압축을 적용한 후 ETC1S로 이미지 형식을 변환하였다.


# 4. 그 밖의 최적화
### glTF 최적화
모델 생성 과정에서 중복되거나 사용하지 않는 데이터를 gltf-transform 툴을 이용하여 제거 하였다.

### .gzip
추가적인 압축을 위해서 Nginx를 통한 gzip 압축을 진행하였다.


# 5. 명령어
gltf-pipeline과 gltf-transform 라이브러리를 설치한다.

### 텍스쳐 분리

```bash
gltf-pipeline -i shop.glb -o untitled.gltf -t -j -s
```

### oxipng

```bash
gltf-transform oxipng untitled.gltf untitled.gltf --verbose
```

### etc1s

```bash
gltf-transform etc1s untitled.gltf untitled.gltf --verbose
```

### debup

```bash
gltf-transform dedup untitled.gltf untitled.gltf
```

### prune

```bash
gltf-transform dedup untitled.gltf untitled.gltf
```

### Draco 압축

```bash
gltf-pipeline -i untitled.gltf -o Draco.gltf -d --draco.compressionLevel 10 --draco.quantizePositionBits 20
```

```bash
gltf-transform draco untitled.gltf Draco1.gltf
```

### meshopt 압축

```bash
gltf-transform meshopt untitled.gltf meshopt.gltf
```

### gltf to glb

```bash
gltf-pipeline -i Draco.gltf -b
```

